<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vision Board</title>
    <!-- Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 폰트 설정 및 기본 스타일 */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }

        canvas {
            border: 2px solid #e5e7eb;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            background-color: white;
            touch-action: none;
            /* 모바일에서 기본 터치 이벤트를 막아 캔버스 드래그를 원활하게 함 */
        }

        /* 파일 입력 숨기기 및 커스텀 버튼 스타일링 */
        #fileInput {
            display: none;
        }
    </style>
</head>

<body class="p-4 md:p-8 flex flex-col items-center min-h-screen">

    <div class="max-w-4xl w-full">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-2">사진 캔버스 편집기</h1>
        <p class="text-gray-500 mb-6">다수의 이미지를 업로드하고, 이동, 크기 조절, 회전하여 배치해보세요. (브라우저를 닫아도 상태가 유지됩니다.)</p>

        <!-- 컨트롤 패널 -->
        <div class="flex flex-col sm:flex-row gap-4 mb-6 p-4 bg-white rounded-xl shadow-md border border-gray-100">

            <label for="fileInput"
                class="cursor-pointer inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-lg shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition duration-150 ease-in-out w-full sm:w-auto">
                <svg class="w-5 h-5 mr-2 -ml-1" fill="currentColor" viewBox="0 0 20 20"
                    xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M5.5 13a4.5 4.5 0 01-9 0 4.5 4.5 0 019 0zm11-4a4.5 4.5 0 01-9 0 4.5 4.5 0 019 0zM12 2a2 2 0 00-2 2v1h4V4a2 2 0 00-2-2zM4 9a2 2 0 00-2 2v6a2 2 0 002 2h12a2 2 0 002-2v-6a2 2 0 00-2-2H4z">
                    </path>
                </svg>
                사진 선택 (다중 선택 가능)
            </label>
            <input type="file" id="fileInput" accept="image/*" multiple>

            <button id="clearButton"
                class="px-4 py-2 text-sm font-medium rounded-lg text-red-600 bg-red-100 hover:bg-red-200 transition duration-150 ease-in-out w-full sm:w-auto">
                캔버스 초기화 (저장된 데이터 삭제)
            </button>
            <div class="text-sm font-medium text-gray-700 self-center">
                선택된 이미지: <span id="selectedImageName" class="font-semibold text-indigo-600">없음</span>
            </div>
        </div>

        <!-- 캔버스 영역 -->
        <div class="flex justify-center items-center w-full h-auto min-h-[500px]">
            <canvas id="imageCanvas"></canvas>
        </div>
    </div>

    <script>
        // 전역 변수 설정
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('fileInput');
        const clearButton = document.getElementById('clearButton');
        const selectedImageNameDisplay = document.getElementById('selectedImageName');

        // 캔버스 크기 설정 (반응형)
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 500;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // 이미지 데이터 배열 (캔버스에 표시될 모든 이미지 객체)
        let images = [];

        // 상태 변수
        let selectedImage = null; // 현재 선택된 이미지 객체
        let isDragging = false;
        let isResizingOrRotating = false;
        let startX, startY; // 마우스 클릭 시작 위치
        let originalProps = {}; // 드래그/변형 시작 시 이미지의 원본 속성 저장

        // 상수
        const CONTROL_HANDLE_SIZE = 12; // 조절 핸들 크기
        const STORAGE_KEY = 'canvasImageEditorState'; // 로컬스토리지 키

        /**
         * 이미지 객체의 구조
         * {
         * img: HTMLImageElement, // 렌더링을 위한 실제 이미지 객체 (저장 시 제외)
         * x: number,
         * y: number,
         * width: number,
         * height: number,
         * rotation: number, // 라디안
         * name: string,
         * base64Data: string // 이미지 파일의 Base64 인코딩 데이터 (저장용)
         * }
         */

        // --- 데이터 저장/로드 함수 (Local Storage) ---

        /**
         * 현재 캔버스 상태를 로컬스토리지에 저장합니다.
         */
        function saveImages() {
            try {
                // 저장할 수 있도록 'img' 객체를 제외한 속성만 추출
                const storableImages = images.map(img => ({
                    x: img.x,
                    y: img.y,
                    width: img.width,
                    height: img.height,
                    rotation: img.rotation,
                    name: img.name,
                    base64Data: img.base64Data
                }));
                localStorage.setItem(STORAGE_KEY, JSON.stringify(storableImages));
                console.log("캔버스 상태가 로컬스토리지에 저장되었습니다.");
            } catch (e) {
                console.error("로컬스토리지에 저장 중 오류가 발생했습니다:", e);
                // Safari private mode 등에서 QuotaExceededError 발생 가능
            }
        }

        /**
         * 로컬스토리지에서 캔버스 상태를 로드합니다.
         */
        function loadImages() {
            try {
                const storedData = localStorage.getItem(STORAGE_KEY);
                if (storedData) {
                    const loadedImagesData = JSON.parse(storedData);
                    images = []; // 기존 데이터 초기화

                    let imagesLoadedCount = 0;
                    loadedImagesData.forEach(data => {
                        const img = new Image();
                        img.onload = () => {
                            // 로드된 이미지 데이터에 HTMLImageElement 인스턴스를 추가하여 배열에 푸시
                            images.push({
                                ...data,
                                img: img // 실제 이미지 객체
                            });
                            imagesLoadedCount++;
                            // 모든 이미지가 로드되면 그리기 시작
                            if (imagesLoadedCount === loadedImagesData.length) {
                                draw();
                            }
                        };
                        // Base64 데이터를 사용하여 이미지 로드
                        img.src = data.base64Data;
                    });
                    console.log(`${loadedImagesData.length}개의 이미지를 로컬스토리지에서 로드 시도합니다.`);
                } else {
                    console.log("로컬스토리지에 저장된 이미지가 없습니다.");
                }
            } catch (e) {
                console.error("로컬스토리지에서 로드 중 오류가 발생했습니다:", e);
            }
        }

        // --- 유틸리티 함수 ---

        /**
         * 캔버스 상대 좌표를 얻습니다.
         * @param {MouseEvent | TouchEvent} event - 이벤트 객체
         * @returns {{x: number, y: number}} - 캔버스 좌표
         */
        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            if (event.touches) {
                // 터치 이벤트 처리
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                // 마우스 이벤트 처리
                clientX = event.clientX;
                clientY = event.clientY;
            }

            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        /**
         * 이미지 객체 로드 및 초기화 (파일을 Base64로 변환하여 저장)
         * @param {File} file - 이미지 파일 객체
         */
        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const base64Data = e.target.result;
                const img = new Image();

                img.onload = () => {
                    // 이미지의 가로/세로 비율 유지하며 초기 크기 설정
                    const scale = Math.min(1, Math.min(CANVAS_WIDTH / img.width / 2, CANVAS_HEIGHT / img.height / 2));
                    const newWidth = img.width * scale;
                    const newHeight = img.height * scale;

                    const newImage = {
                        img: img, // 실제 HTMLImageElement 인스턴스 (렌더링용)
                        x: (CANVAS_WIDTH - newWidth) / 2, // 캔버스 중앙에 배치
                        y: (CANVAS_HEIGHT - newHeight) / 2,
                        width: newWidth,
                        height: newHeight,
                        rotation: 0, // 초기 회전 각도 0
                        name: file.name,
                        base64Data: base64Data // Base64 데이터 (저장용)
                    };

                    images.push(newImage);
                    // 새로 로드된 이미지를 선택
                    selectedImage = newImage;
                    updateSelectedImageName();
                    saveImages(); // 이미지 로드 후 상태 저장
                    draw();
                };
                img.src = base64Data;
            };
            reader.readAsDataURL(file); // 파일 내용을 Base64로 읽기
        }

        // --- 렌더링 함수 ---

        /**
         * 캔버스 전체를 다시 그립니다.
         */
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 모든 이미지를 그립니다.
            images.forEach(image => {
                // 이미지 로드가 완료되었는지 확인
                if (image.img && image.img.complete) {
                    drawImage(image);
                }

                // 선택된 이미지인 경우 컨트롤을 그립니다.
                if (image === selectedImage) {
                    drawControls(image);
                }
            });
        }

        /**
         * 단일 이미지 객체를 캔버스에 그립니다. (변환 적용)
         * @param {object} image - 이미지 객체
         */
        function drawImage(image) {
            ctx.save();

            // 캔버스 원점 이동: 이미지의 중심(rotation center)으로 이동
            const centerX = image.x + image.width / 2;
            const centerY = image.y + image.height / 2;
            ctx.translate(centerX, centerY);

            // 회전 적용
            ctx.rotate(image.rotation);

            // 이미지 그리기: translate 했으므로, 중심을 원점 (0,0)으로 이동
            // x, y 좌표는 (-width/2, -height/2)가 됩니다.
            ctx.drawImage(image.img, -image.width / 2, -image.height / 2, image.width, image.height);

            ctx.restore();
        }

        /**
         * 선택된 이미지의 컨트롤 핸들을 그립니다.
         * @param {object} image - 선택된 이미지 객체
         */
        function drawControls(image) {
            ctx.save();

            // 캔버스 원점 이동 및 회전 적용 (이미지 그리기와 동일)
            const centerX = image.x + image.width / 2;
            const centerY = image.y + image.height / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate(image.rotation);

            // 1. 테두리 (경계 상자) 그리기
            ctx.strokeStyle = '#4f46e5'; // 보라색
            ctx.lineWidth = 2;
            // 회전된 좌표계에서 이미지는 (-width/2, -height/2)부터 시작합니다.
            ctx.strokeRect(-image.width / 2, -image.height / 2, image.width, image.height);

            // 2. 크기 조절/회전 핸들 그리기 (오른쪽 아래 모서리)
            const handleX = image.width / 2;
            const handleY = image.height / 2;

            ctx.fillStyle = isResizingOrRotating ? '#ef4444' : '#3b82f6'; // 활성화 시 빨간색, 평상시 파란색
            ctx.beginPath();
            // 핸들을 그릴 때, 핸들 크기만큼 역으로 이동하여 핸들 중심이 모서리에 오도록 합니다.
            ctx.rect(handleX - CONTROL_HANDLE_SIZE / 2, handleY - CONTROL_HANDLE_SIZE / 2, CONTROL_HANDLE_SIZE, CONTROL_HANDLE_SIZE);
            ctx.fill();
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#fff';
            ctx.stroke();

            ctx.restore();
        }

        // --- 충돌 및 위치 계산 함수 ---

        /**
         * 점이 이미지 내부에 있는지 확인합니다. (회전 고려)
         * @param {number} x - 마우스 x 좌표
         * @param {number} y - 마우스 y 좌표
         * @param {object} image - 이미지 객체
         * @returns {boolean}
         */
        function isPointInImage(x, y, image) {
            const centerX = image.x + image.width / 2;
            const centerY = image.y + image.height / 2;

            // 1. 마우스 좌표를 이미지의 로컬(회전되지 않은) 좌표계로 변환합니다.
            const angle = -image.rotation; // 역회전
            const sin = Math.sin(angle);
            const cos = Math.cos(angle);

            // 마우스 좌표를 중심으로 이동
            const dx = x - centerX;
            const dy = y - centerY;

            // 역회전 적용
            const rotatedX = dx * cos - dy * sin;
            const rotatedY = dx * sin + dy * cos;

            // 2. 로컬 좌표가 이미지 경계 내부에 있는지 확인합니다.
            // 로컬 좌표계에서 이미지의 경계는 (-width/2, -height/2) ~ (width/2, height/2)
            return rotatedX >= -image.width / 2 &&
                rotatedX <= image.width / 2 &&
                rotatedY >= -image.height / 2 &&
                rotatedY <= image.height / 2;
        }

        /**
         * 점이 크기 조절/회전 핸들 내부에 있는지 확인합니다. (회전 고려)
         * @param {number} x - 마우스 x 좌표
         * @param {number} y - 마우스 y 좌표
         * @param {object} image - 이미지 객체
         * @returns {boolean}
         */
        function isPointInHandle(x, y, image) {
            if (image !== selectedImage) return false;

            const centerX = image.x + image.width / 2;
            const centerY = image.y + image.height / 2;

            // 1. 마우스 좌표를 이미지의 로컬 좌표계로 변환합니다.
            const angle = -image.rotation;
            const sin = Math.sin(angle);
            const cos = Math.cos(angle);

            const dx = x - centerX;
            const dy = y - centerY;

            const rotatedX = dx * cos - dy * sin;
            const rotatedY = dx * sin + dy * cos;

            // 2. 로컬 좌표가 오른쪽 하단 핸들 영역 내부에 있는지 확인합니다.
            const handleHalfSize = CONTROL_HANDLE_SIZE / 2;
            const handleLeft = image.width / 2 - handleHalfSize;
            const handleRight = image.width / 2 + handleHalfSize;
            const handleTop = image.height / 2 - handleHalfSize;
            const handleBottom = image.height / 2 + handleHalfSize;

            return rotatedX >= handleLeft &&
                rotatedX <= handleRight &&
                rotatedY >= handleTop &&
                rotatedY <= handleBottom;
        }

        // --- 이벤트 핸들러 ---

        /**
         * 현재 선택된 이미지의 이름을 UI에 업데이트합니다.
         */
        function updateSelectedImageName() {
            selectedImageNameDisplay.textContent = selectedImage ? selectedImage.name : '없음';
        }

        /**
         * 마우스 다운 (또는 터치 시작) 이벤트 처리
         * @param {MouseEvent | TouchEvent} event - 이벤트 객체
         */
        function handleMouseDown(event) {
            const pos = getMousePos(event);
            startX = pos.x;
            startY = pos.y;

            let clickedImage = null;

            // 역순으로 검사하여 가장 위에 있는 이미지(가장 나중에 그려진 이미지)를 선택합니다.
            for (let i = images.length - 1; i >= 0; i--) {
                const image = images[i];
                if (isPointInHandle(pos.x, pos.y, image)) {
                    // 핸들을 클릭했으면, 해당 이미지를 선택하고 변형 모드로 진입
                    selectedImage = image;
                    isResizingOrRotating = true;
                    isDragging = false;

                    // 변형을 위한 원본 속성 저장
                    originalProps = {
                        x: image.x,
                        y: image.y,
                        width: image.width,
                        height: image.height,
                        rotation: image.rotation,
                        centerX: image.x + image.width / 2,
                        centerY: image.y + image.height / 2,
                        mouseAngle: Math.atan2(startY - (image.y + image.height / 2), startX - (image.x + image.width / 2))
                    };
                    updateSelectedImageName();
                    draw();
                    return; // 핸들 클릭 시 바로 리턴
                }

                if (isPointInImage(pos.x, pos.y, image)) {
                    clickedImage = image;
                    break; // 이미지 본체 클릭 확인 후 루프 종료
                }
            }

            if (clickedImage) {
                // 이미지 본체를 클릭했으면, 해당 이미지를 선택하고 드래그 모드로 진입
                selectedImage = clickedImage;
                isDragging = true;
                isResizingOrRotating = false;

                // 선택된 이미지를 배열의 맨 뒤로 이동 (가장 위에 보이도록)
                images = images.filter(img => img !== selectedImage);
                images.push(selectedImage);

                // 드래그를 위한 원본 위치 저장
                originalProps = { x: selectedImage.x, y: selectedImage.y };

                updateSelectedImageName();
            } else {
                // 아무것도 클릭하지 않았으면 선택 해제
                selectedImage = null;
                isDragging = false;
                isResizingOrRotating = false;
                updateSelectedImageName();
            }

            draw();
        }

        /**
         * 마우스 이동 (또는 터치 이동) 이벤트 처리
         * @param {MouseEvent | TouchEvent} event - 이벤트 객체
         */
        function handleMouseMove(event) {
            if (!selectedImage || (!isDragging && !isResizingOrRotating)) return;
            event.preventDefault(); // 드래그/변형 중 브라우저 기본 동작 방지 (터치 스크롤 방지 등)

            const pos = getMousePos(event);
            const dx = pos.x - startX;
            const dy = pos.y - startY;

            if (isDragging) {
                // --- 이동 (Drag) 로직 ---
                selectedImage.x = originalProps.x + dx;
                selectedImage.y = originalProps.y + dy;

            } else if (isResizingOrRotating) {
                // --- 크기 조절 및 회전 로직 ---

                const currentAngle = Math.atan2(pos.y - originalProps.centerY, pos.x - originalProps.centerX);

                // 회전: 마우스 시작 각도와 현재 각도의 차이를 반영
                selectedImage.rotation = originalProps.rotation + (currentAngle - originalProps.mouseAngle);

                // 크기 조절: 중심으로부터의 거리 변화를 사용
                const startDist = Math.hypot(startX - originalProps.centerX, startY - originalProps.centerY);
                const currentDist = Math.hypot(pos.x - originalProps.centerX, pos.y - originalProps.centerY);
                const scaleFactor = currentDist / startDist;

                // 새 크기 계산
                const newWidth = originalProps.width * scaleFactor;
                const newHeight = originalProps.height * scaleFactor;

                // 크기가 너무 작아지는 것을 방지
                const MIN_SIZE = 20;
                if (newWidth > MIN_SIZE && newHeight > MIN_SIZE) {
                    selectedImage.width = newWidth;
                    selectedImage.height = newHeight;

                    // 크기가 변하면, 이미지 위치도 중심점을 기준으로 다시 계산
                    selectedImage.x = originalProps.centerX - selectedImage.width / 2;
                    selectedImage.y = originalProps.centerY - selectedImage.height / 2;
                }
            }

            draw();
        }

        /**
         * 마우스 업 (또는 터치 종료) 이벤트 처리
         */
        function handleMouseUp() {
            if (selectedImage && (isDragging || isResizingOrRotating)) {
                // 변형이 발생했을 때만 저장
                saveImages();
            }
            isDragging = false;
            isResizingOrRotating = false;
            originalProps = {}; // 임시 속성 초기화
            draw(); // 변형 완료 후 최종적으로 다시 그리기
        }

        // --- 이벤트 리스너 등록 ---

        // 파일 입력 변경 시 이미지 로드
        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            files.forEach(file => loadImage(file));
            e.target.value = ''; // 동일 파일 재선택을 위해 초기화
        });

        // 캔버스 초기화 버튼
        clearButton.addEventListener('click', () => {
            images = [];
            selectedImage = null;
            updateSelectedImageName();
            localStorage.removeItem(STORAGE_KEY); // 로컬스토리지에서도 삭제
            draw();
            console.log("캔버스가 초기화되고 로컬스토리지 데이터가 삭제되었습니다.");
        });

        // 마우스 및 터치 이벤트 리스너 (반응형 상호작용을 위해 모두 등록)
        canvas.addEventListener('mousedown', handleMouseDown);
        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) handleMouseDown(e);
        }, { passive: false });

        window.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1) handleMouseMove(e);
        }, { passive: false });

        window.addEventListener('touchend', handleMouseUp);
        window.addEventListener('touchcancel', handleMouseUp);


        // 초기 로딩 시 로컬스토리지에서 데이터 로드
        window.onload = () => {
            loadImages(); // 로드된 이미지가 비동기로 로드 완료되면 draw() 호출
            draw(); // 저장된 데이터가 없을 경우 빈 캔버스 그리기
        };

    </script>
</body>

</html>